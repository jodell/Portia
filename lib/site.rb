#puts $:

require 'yaml'
require 'lib/wtf_constants'

class String
  def singular
    self.gsub(/(s|es)(\s|$)/, '')
  end
end

##
# Taken shamelessly from http://snippets.dzone.com/posts/show/5811
# UPDATE:  Changed method name to be an addition instead of a rewrite.
# -jodell 20090805
#
class Hash
  # Replacing the to_yaml function so it'll serialize hashes sorted (by their keys)
  #
  # Original function is in /usr/lib/ruby/1.8/yaml/rubytypes.rb
  def to_sorted_yaml( opts = {} )
    YAML::quick_emit( object_id, opts ) do |out|
      out.map( taguri, to_yaml_style ) do |map|
        sort.each do |k, v|   # <-- here's my addition (the 'sort')
          map.add( k, v )
        end
      end
    end
  end
end


##
# Open YAML.dump to support the addition to Hash, Hash#to_sorted_yaml.
# There is probably a neater way of doing this.  -jodell 20090805
#
module YAML
  def YAML.dump( obj, io = nil )
    if obj.respond_to?(:to_sorted_yaml) then
      obj.to_sorted_yaml( io || io2 = StringIO.new )
    else 
      obj.to_yaml( io || io2 = StringIO.new )
    end
    io || ( io2.rewind; io2.read )
  end
end


##
# WTF - Web Testing Framework:
# A collection of 
#
#
#
module WTF

  # A site is a collection of pages with a notion of page flow
  # that's defined by valid transitions.
  #
  class Site
    attr_accessor :site, :pages, :transitions

    ##
    # Expects a WTF::Site formatted YAML file.
    #
    def initialize(sitefile = '')
      @pages = load_pages(sitefile)
      @transitions = load_transitions(@pages)
    end

    ##
    # Given a sitefile, process it and return an array of Page objects
    #
    def load_pages(sitefile)
      # Setup all page objects
      raise ArgumentError, "Site file, #{sitefile} not found!" unless File.exists?(sitefile)
      @site = YAML::load_file(sitefile)

      # Return the set of pages
      @site['pages'].collect do |page|
        # load page class
        load_page([File.expand_path(File.dirname(sitefile)), page] * '/')
      end
    end

    ##
    # Process a pagefile and return the Page object
    #
    def load_page(pagefile)
      # Instantiate each page here
      WTF::Page.new(pagefile)
    end

    ##
    # Transitions are meant to be a logical mapping of valid page flows.  It can ultimately
    # be used to define and generate testcases automatically.
    #
    def load_transitions(page_set)
      # Setup transitions from an array of page objects
    end

    ##
    # bracket access to the page array.  If an index is given, treat as an Array.  Return pages 
    # after searching on the name otherwise.
    #
    def [](page)
      case page 
      when Integer then @pages[page]
      when String then 
        (pages = @pages.select { |p| p.names.include?(page) }).size > 1 ? pages : pages.first
      end
    end

    ##
    # Allow for 'site.page1' notation.  Pages themselves do the same for HTML elements,
    # allowing for site.page1.field1 in turn.
    #
    def method_missing(method, *args)
      if @pages.collect { |p| p.names }.flatten.include?(method.to_s) then
        the_page = @pages.find { |p| p.names.include?(method.to_s) }
        args.empty? ? the_page : the_page.send(args[0].to_sym, *args)
      else
        super
      end
    end

  end # Site

  # The Page class represents a collection of HTML elements and allows for 
  # programmatic access.  It's driven by YAML which should ultimately be 
  # generated by a spider.
  #
  class Page
    attr_accessor :mypage, :names, :elements, :all
    # Checkboxes are really of typ input, this may have to change

    def initialize(pagefile)
      @elements = {} 
      @all = {}
      load_page(pagefile)
    end

    def load_page(pagefile)
      raise ArgumentError, "Page file, #{pagefile} not found!" unless File.exists?(pagefile)
      @mypage = YAML::load_file(pagefile)
      ELEMENT_TYPES.each do |e|
        @mypage[e].to_s && @elements[e].nil? ? @elements[e] = @mypage[e.to_s] : @elements[e].merge(@mypage[e.to_s])
        @all.merge!(@elements[e]) if @elements[e] 
      end
      #@elements = @mypage['elements']
      @names = @mypage['names']
      set_mappings
    end

    ##
    # Set mappings for user-identified elements
    #
    def set_mappings
      @mypage['mappings'].each do |element, aliases|
        aliases.each { |a| @all[a] = @all[element].dup }
      end
    end
   
    ##
    # Allow for 'site.page1' notation.  Pages themselves do the same for HTML elements,
    # allowing for site.page1.field1 in turn.
    #
    def method_missing(method, *args)
      if ELEMENT_TYPES.include?(method) then
        @elements[method]
      elsif @all.include? method.to_s
        @all[method.to_s]['xpath'] # Return xpath for now
      else
        super
      end
    end

    ##
    # Given a hash of data, attempt to match the list canonicalized names of the page elements
    # with the keys of the hash parameter and form fill them
    #
    def form_fill_with(hsh)
    end

  end # Page

  ##
  # Given an HTML source, generate a WTF::Page formatted YAML file
  #
  class PageGenerator
    attr_accessor :browser
    def initialize
    end
  end

end # WTF

##### Example #####
#cnu = WTF::Site.new('cashnetusa.com.yml')
#cnu.pages             # => Array of page objects
#cnu[:home].to_s       # => 'http://cashnetusa.com'
#cnu.pages[:home].to_s # => 'http://cashnetusa.com'
#cnu.homepage.login    # => Sends 'login' to the homepage page class in cnu#pages, returns the locator
#
#qq = WTF::Site.new('quickquid.co.uk.yml')

##### Example sitefile #####
# url: cashnetusa.com
# pages: 
# - pages/homepage => 'homepage.yml'
# - pages/reg1 => 'reg1.yml'
# - pages/reg2 => 'reg2.yml'
# flows:
# - homepage, reg1, reg2
# - reg1, reg2
#
$s = WTF::Site.new(File.expand_path(File.dirname(__FILE__)) + '/../var/cashnetusa.com/cashnetusa.com.yml')

